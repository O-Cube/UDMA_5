//======================================================================================================
// Author  : Obed Oyandut
// Date    : 11.08.2022
// Version : v1
//======================================================================================================
// This program uses TIVA TM4C1294XL Evaluation Board
//======================================================================================================
// This program demonstrates pingpong receive in uart. There are two receive buffers. The udma copies
// 10 characters into the first buffer. When copy is completed in the first register, it proceeds to copy
// in the second buffer. 10 characters are copied into the second buffer. When this is done, an interrupt
// is generated by the uart peripheral. This signals to the processor the end of udma copy. The content of
// both buffer is printed to console. Realterm is used to send the payload. The speed of the communication
// line is 115200MHz and a 8N1 format. The debugging is done in code composer studio.
// TIVA TM4C1294XL uses a single channel for both Tx and Rx interrupts. Software has to determine what
// causes the interrupt by using the MIS.
//========================================================================================================
//                     ! IMPORTANT !
// This program runs endless. Stop with the "Red Square Button"
// in Debug Mode (Terminate = CTRL + F2)
//========================================================================================================

#include "inc/tm4c1294ncpdt.h"
#include <stdint.h>
#include <stdio.h>

//========================================================================================================
// COntrol table length and rxBuffer length
//========================================================================================================

#define LEN 256
#define LEN1 11

//========================================================================================================
// Pair of receive buffer
//========================================================================================================

unsigned char rxBuffer1[LEN1];
unsigned char rxBuffer2[LEN1];

//========================================================================================================
// Control table
//========================================================================================================

unsigned int controlTable[LEN];

//=========================================================================================
// ISR of UART2:
// Interrupt event is produced when udma receives every payload into both buffers. The interrupt is cleared
// using ICR. The content of both buffers is printed to console.
//==========================================================================================

void UartRxTxHandler(void) {

    if (UART2_MIS_R & 0x10000) {

        UART2_ICR_R |= 0x10000;
        printf("DMA receive is done...\n");
        rxBuffer1[10] = '\0';
        rxBuffer2[10] = '\0';
        printf("Buffer1: %s\n", rxBuffer1);
        printf("Buffer2: %s\n", rxBuffer2);
    }
}

//=========================================================================================
// Configuration of UART2:
// Assign clock and wait for uart peripheral to acquire the clock.
// Turn of the uart peripheral for further configuation.
// Assign a speed of 115200bps to uart peripheral
// LCRH:
// word length: 8
// FEN: All FIFOs enabled
// STP: 1 stop bit
// EPS: Reset value
// PEN: Parity disabled
// BRK: No line break
//==========================================================================================

void configUart2(void) {
    SYSCTL_RCGCUART_R |= (1<<2);
    while((SYSCTL_PRUART_R & (1<<2))==0);
    UART2_CTL_R &= ~(1<<0);
    UART2_IBRD_R = 8;
    UART2_FBRD_R = 44;
    UART2_LCRH_R = 0x00000070;
    UART2_DMACTL_R |= 0x03;
    UART2_CTL_R |= 0x311; // CTS is enabled

    //===========================================================================================
    // Configuration UART2 interrupts:
    // IM:
    // DMATXIM = 1 => DMATXRIS in UARTRIS is masked.
    // DMARXIM = 1 => DMARXRIS in UARTRIS is masked.
    // TXIM = 1 => TXRIS in UARTRIS is masked.
    // RXIM = 1 => RXRIS in UARTRIS is masked
    // EN1:
    // Mask interrupt request to NVIC
    // Re enabe uart peripheral after configuration
    // CTL:
    // RXE set => rx enable
    // TXE set => tx enable
    // UARTEN set
    // =================================================================================================

    UART2_IM_R |= 0x30030;
    NVIC_EN1_R |= (0x1<<1);
   // UART2_IFLS_R |= 0x18; // rx is 3/4 full and tx 3/4 empty
    UART2_CTL_R |= 0x301; // CTS is enabled
}

//==========================================================================================
// Configuration of port D for UART:
// Assign clock to PD. Wait for clock to become stable using
// a blocking while loop. Set alternate select of P(4) and PD(5). Set alternate function
// of PD(4) and PD(5)to UART.
//==========================================================================================

void configPortD(void) {
    SYSCTL_RCGCGPIO_R |= (1<<3);
    while((SYSCTL_PRGPIO_R & (1<<3)) == 0);
    GPIO_PORTD_AHB_DEN_R |= 0x030;
    GPIO_PORTD_AHB_AFSEL_R |= 0x030;
    GPIO_PORTD_AHB_PCTL_R |= 0x110000;
}

//==============================================================================================
// Configuration UART2 rx on channel 0:
// RCGCDMA:
// Assigns clock to udma
// PRDMA:
// Wait for udma peripheral to acquire clock signal
// CFG:
// Enable udma controller
// PRIOSET:
// Sets priority of channel 0 to high
// USEBURSTCLR:
// Enables burst transfer in both channel
// CHAP0:
// Select udma source uart2 rx
// CTLBASE:
// Assign base control table
// ENASET:
// Enable channel 0 for use
//=============================================================================================================

void udmaConfig(void) {

    SYSCTL_RCGCDMA_R |= 0x01;
    while(!(SYSCTL_PRDMA_R & 0x01));
    UDMA_CFG_R |= 0x01;
    UDMA_PRIOSET_R |= 0x01;
    UDMA_USEBURSTCLR_R |= 0x01;
    UDMA_REQMASKCLR_R |= 0x01;
    UDMA_CHMAP0_R |=0x1;
    UDMA_CTLBASE_R = (unsigned int)controlTable;
    UDMA_ENASET_R = 0x01;
}

//===============================================================================================
// COnfiguarion of base control table
//===============================================================================================

void baseTableConfig(void) {

    //==============================================================================================
    // Primary control structure of channel 1
    // Control word:
    // DSTINC = byte
    // DSTSIZE = byte
    // SRCINC = no increment
    // SRCSIZE = byte
    // ARBSIZE = 2
    // XFERSIZE = 10
    // XFERMODE = pingpong
    //===============================================================================================

    controlTable[0] = (unsigned int)&UART2_DR_R;
    controlTable[1] = (unsigned int)&rxBuffer1[9];
    controlTable[2] = 0x0C0040A3;

    //==============================================================================================
    // Alternate control structure of channel 1
    // Control word:
    // DSTINC = byte
    // DSTSIZE = byte
    // SRCINC = no increment
    // SRCSIZE = byte
    // ARBSIZE = 2
    // XFERSIZE = 10
    // XFERMODE = pingpong
    //===============================================================================================

    controlTable[128] = (unsigned int)&UART2_DR_R;
    controlTable[129] = (unsigned int)&rxBuffer2[9];
    controlTable[130] = 0x0C0040A3;

}



void main(void) {

    configUart2();
    configPortD();
    baseTableConfig();
    udmaConfig();
    UART2_DR_R = '>';

    while(1)
    {

        //========================================================================================================
        // Infinite loop. Processor waits for evvents to occur. When these events occur, the processor goes into
        // an interrupt service routine.
        //========================================================================================================

    }
}
